<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>TORCS: Architecture Overview</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="Ticon.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">TORCS
   &#160;<span id="projectnumber">1.3.7</span>
   </div>
   <div id="projectbrief">The Open Racing Car Simulator</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('architecture.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Architecture Overview </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The goal of this chapter is to give an introduction into the major TORCS concepts and components, and to document where you find them in the source tree. The TORCS architecture view presented here identifies 3 major component types. These are components responsible for controlling the major program flow (Orchestration), interfaces and libraries with common code (TORCS API and Libraries) and modules loaded during run time (Plugins).</p>
<div class="image">
<img src="architecture.png" alt="architecture.png"/>
<div class="caption">
Architecture Overview</div></div>
 <h2>Entry Stage </h2>
<p>At start up TORCS goes first through the Entry stage. During this stage the command line is analysed, and depending on the desired operation mode TORCS is run either with a command line specified race configuration file in command line mode (option -r), or the graphical menu is started. The command line mode does not output any graphics, and the simulation time is not synchronized with real time, so this mode is ideal to run simulations without human supervisor as fast as possible. The relevant code is in <a class="el" href="linux_2main_8cpp.html">src/linux/main.cpp</a> for Posix systems, or in <a class="el" href="windows_2main_8cpp.html">src/windows/main.cpp</a> for Windows systems.</p>
<p>The command line mode starts up directly the State Engine in <a class="el" href="raceinit_8cpp.html">src/libs/raceengineclient/raceinit.cpp</a>, <a class="el" href="raceinit_8h.html#a1b414665c217755fd685113156f3022d">ReRunRaceOnConsole</a>, it is an excellent starting point to review the minimum required setup to start up, run and shutdown the simulation.</p>
<h2>Menu </h2>
<p>The Menu and its components are responsible to offer a visual user interface to ease the setup of TORCS, e.g. the selection of predefined races, changing the selection of robots, graphics and much more. All these settings are persisted in XML files and are read later by the respective components.</p>
<p>The Race menu is a special menu, because the entries presented here are the direct reflection of Race Manager configuration files (look up src/raceman). You can completely customize the Race Manager configuration files if desired (that means adding, removing, renaming and editing), they offer the creation of very simple sessions (e.g. practice.xml) up to full championships (e.g. champ.xml).</p>
<p>When the user finally selects a Race Manager the State Engine is started up in <a class="el" href="raceinit_8cpp.html">src/libs/raceengineclient/raceinit.cpp</a>, <a class="el" href="raceinit_8cpp.html#a5a1f5ce5a44d66b81a8e462994729324">reSelectRaceman</a>.</p>
<h2>State Engine </h2>
<p>The State Engine controls the execution of the Race manager specific configuration, setup, run and shutdown of the simulation (<a class="el" href="racestate_8cpp.html">src/libs/raceengineclient/racestate.cpp</a>, <a class="el" href="racestate_8h.html#a049810dfed9900705f82ec174358bc18">ReStateManage</a>). To trigger state changes the state of TORCS data can be inspected or for more simple cases the return value of a function call can be considered. Understanding of the State Engine can make some tasks really simple, e.g. implementing a robot which can restart the simulation by itself (not supported by TORCS out of the box, but very easy to add, see <a href="http://torcs.sourceforge.net/index.php?name=Sections&amp;op=viewarticle&amp;artid=30#c6_8">TORCS FAQ 6.8</a>).</p>
<div class="image">
<img src="raceenginestate.gif" alt="raceenginestate.gif"/>
<div class="caption">
State Engine</div></div>
 <h2>TORCS API and Libraries </h2>
<p>TORCS defines some interfaces and libraries which are used in multiple parts of the project, e.g. XML parameter file handling, common functions for robots, etc. The header files for the interfaces can be found in <a class="el" href="dir_ee3f1a7951c308657a65f8199076c1d6.html">src/interfaces</a>, the libraries in <a class="el" href="dir_87a455bccb09a92130c26a11a880c98a.html">src/libs</a>, the most interesting ones for robot programming are <a class="el" href="group__params.html">parameter handling</a>, <a class="el" href="group__robottools.html">robottools</a>, <a class="el" href="dir_db0ab3cf1dad8cf7a28c46622fc3263f.html">portability</a>, <a class="el" href="dir_defb122bfee2d1e99c430b37bff7dd0f.html">math</a> and <a class="el" href="dir_ad16b323516c905f6a9c6be33343c52b.html">learning</a>.</p>
<h2>Plugins </h2>
<p>The Plugins share all in common that they have specified interfaces and are loaded based on the configuration during run time, so if you have an alternative plugin you can configure TORCS to use it. As example there are two simulation implementations, <a class="el" href="dir_71e35f7fd2c517de446cb51ca88f779c.html">simuv2</a> and simuv3, you can simply change a configuration file to change it. Typical use cases are replacing some of the actual modules with wrappers or adapters, e.g. to run the simulation on MATLAB or to run robots with simulated sensors over the network on other machines (<a href="http://scr.geccocompetitions.com">SCR</a>). The interface definitions can be reviewed <a class="el" href="group__modint.html">here</a>.</p>
<h3>Rendering</h3>
<p>Rendering (<a class="el" href="group__graphicmodint.html">Graphic Module Interface</a>) is responsible for rendering the situation. The current default implementation does visual 3D rendering including sound, based on the OpenGL 1.3 and OpenAL API's. The interface is specified in <a class="el" href="graphic_8h.html" title="Graphic Module Interface Definition. ">src/interfaces/graphic.h</a>. The major function is <a class="el" href="group__graphicmodint.html#ga6e1032c7d11fa79dc1ea3b969688a1ab">refresh</a>, which takes as argument a <a class="el" href="struct_situation.html">struct Situation *</a> and renders it. The code of the actual module is located in <a class="el" href="dir_d7cbf3a3b3bc7693caf0953e4137fd81.html">src/modules/graphic/ssggraph</a>.</p>
<h3>Simulation</h3>
<p>Simulation (<a class="el" href="group__simumodint.html">Simulation Module Interface</a>) is responsible for progressing the situation by a given time step. The interface is specified in <a class="el" href="simu_8h.html" title="Simulation Module Interface Definition. ">src/interfaces/simu.h</a>. The major function is <a class="el" href="group__simumodint.html#ga98d9af29aa41ee6bc0466a31ceb129e6">update</a>, which takes the <a class="el" href="struct_situation.html">struct Situation *</a> and simulation timestep (usually <a class="el" href="raceman_8h.html#a4ee107730ee9d3c8fb701398ea04ef92">RCM_MAX_DT_SIMU</a>) as argument, and progresses the simulation by the time step. The code of the default module is located in <a class="el" href="dir_71e35f7fd2c517de446cb51ca88f779c.html">src/modules/simu/simuv2</a>.</p>
<h3>Track</h3>
<p>Track (<a class="el" href="group__trackmodint.html">Track Loader Module Interface</a>) is responsible for loading tracks into the TORCS <a class="el" href="structt_track.html" title="Track structure. ">tTrack</a> structure. The interface is specified in <a class="el" href="track_8h.html" title="Track Structure and Track Loader Module Definition. ">src/interfaces/track.h</a>. The code of the default module is located in <a class="el" href="dir_1182ac64499bfddb831236a21400021d.html">src/modules/track</a>.</p>
<h3>Robot</h3>
<p>The robot module(s) (<a class="el" href="group__robotmodint.html">Robot Module Interface</a>) drive the cars in the simulation. TORCS can load multiple robots at the same time to drive multiple cars, one robot supports up to 10 cars at once. The major function is <a class="el" href="group__robotmodint.html#ga985832a785f567697207ae5c70207d84">rbDrive</a>, which takes as argument an index of the car to drive with the call, a <a class="el" href="car_8h.html#adf856b7254cf55e8ec02c19ee50d6834">tCarElt *</a> containing information about the car and a <a class="el" href="struct_situation.html">struct Situation *</a> containing the situation. As result the call fills in the <a class="el" href="structt_car_ctrl.html" title="Info returned by driver during the race. ">tCarCtrl</a> struct, which contains commands to drive the car (steer, brake, accelerator,clutch, ...). The interface is specified in <a class="el" href="robot_8h.html" title="Robot Module Interface Definition. ">src/interfaces/robot.h</a>. Various drivers implementations are shipped with TORCS, have a look into src/drivers. Specially to mention is the "Human Driver" (human), it takes input from the user to control the car, so if your experiment requires adoption regarding user input have a look at this robot.</p>
<p>The Olethros and bt robot are able to adopt to the track over time and persist the gained knowledge for later runs. If you are interested in other implementations, you can find more robots on <a href="http://www.berniw.org/trb">The TORCS Racing Board</a> (you can download robots of past events) or on the <a href="http://scr.geccocompetitions.com">SCR</a> site.</p>
<h1>Simulation Loop Internals </h1>
<p>After discussing the TORCS architecture we are now ready to dig into some details of the simulation loop. This seems to be a topic which is usually not too easy to understand. Let start with taking about time. There are two different times in TORCS, simulation time and real time. The simulation time is basically just the time axis on which we calculate the simulation intermediate results, so if it takes 1 real minute or 1 real ms to simulate 1s in simulation time, the simulation time is just one second, real time does not matter. Real time in contrary is the time observed by the user. So it is very important to understand that the whole TORCS architecture just uses simulation time to perform calculations, evaluation of rules etc., real time does not matter in that respect. Real time is only used to synchronize in some modes simulation time with real time, e.g. to enable a human to drive a car.</p>
<p>The TORCS Simulation Loop starts in the State Engine, <a class="el" href="racestate_8cpp.html">src/libs/raceengineclient/racestate.cpp</a>, <a class="el" href="racestate_8h.html#a049810dfed9900705f82ec174358bc18">ReStateManage</a>, case <a class="el" href="raceman_8h.html#a7c7248690dedffef8c4da76b14e93eb3">RE_STATE_RACE</a>. In mode=<a class="el" href="raceengine_8cpp.html#a209253ea6c2b42ddd43dabcaa9f62104">ReUpdate()</a>; everything is performed, and if the race is still normally running the State Engine while loop will return into the same state again and again, till some condition for a state change is fulfilled (e.g. when the race has ended).</p>
<p><a class="el" href="raceengine_8h.html#a209253ea6c2b42ddd43dabcaa9f62104">ReUpdate</a> is located in <a class="el" href="raceengine_8cpp.html">src/libs/raceengineclient/raceengine.cpp</a>. It has four distinct operating modes:</p>
<h2>Interactive Mode </h2>
<p><a class="el" href="raceman_8h.html#af1ac49caf6a067b5e7826930c02b503f">RM_DISP_MODE_NORMAL</a>: This mode is mostly suitable for interactive simulations, it takes into account simulation time and real time. It basically works like this: Progress the simulation time until simulation time has caught up with real time, then render a frame.</p>
<p>Now this has some consequences, because TORCS is usually not the only running process in the operating environment and is usually not running as real time task. So if another process or the operating environment hooks up some resources, it might happen that TORCS sleeps for a moment, and after that nap it has to catch up. So a consequence of this mode is that even if you repeat runs of the exact same simulation in simulation time, that the rendered frames will quite likely not be the identical ones. This can have as well an impact on human player performance, if some frames take very long to appear.</p>
<p>If you want to simulate a video source with exactly one frame every X seconds <a class="el" href="raceman_8h.html#adba544ed4bb16d3fa60788149cc1eaaf">RM_DISP_MODE_CAPTURE</a> might be a better solution. <a class="el" href="raceman_8h.html#af1ac49caf6a067b5e7826930c02b503f">RM_DISP_MODE_NORMAL</a> mode has two more features: If the simulation lags behind a lot and is not able to catch up, it spits out at least a frame on every 2000th time step, this is required to keep the GUI interactive (processing the event queue). There is as well a time warp (up to 128 times real time) and slow motion mode (down to 1/64 times real time).</p>
<h2>Blind Mode </h2>
<p><a class="el" href="raceman_8h.html#aebe23725e71ae158891020a743efde29">RM_DISP_MODE_NONE</a>: This mode is used for the "blind mode" in practice sessions, it does just consider simulation time, no 3D scenery is rendered. Every 2 seconds of simulation time the list in the GUI regarding the current progress is updated. This mode is suitable for development of robots. You can run experiments with almost no overhead, but you can switch quickly in the GUI between runs from and back to <a class="el" href="raceman_8h.html#af1ac49caf6a067b5e7826930c02b503f">RM_DISP_MODE_NORMAL</a> to investigate problems.</p>
<h2>Frame Capturing Mode </h2>
<p><a class="el" href="raceman_8h.html#adba544ed4bb16d3fa60788149cc1eaaf">RM_DISP_MODE_CAPTURE</a>: This mode is used to capture frames at exact points in simulation time (e.g. every 0.03s). The time is not synchronized with real time, so the simulation might be faster or slower than real time, depending on the load you generate. Time warp and slow motion modes are available as well. This would be with some little modification the most suitable mode for creating an AI driving based on video frames.</p>
<h2>Console Mode </h2>
<p><a class="el" href="raceman_8h.html#ad5165860906372865513b315cb2ce782">RM_DISP_MODE_CONSOLE</a>: This mode is used when you start TORCS with the -r option from the command line, it does have no GUI at all, it just prints out some progress information. This mode is intended for batch operation and unit testing.</p>
<h2>Simulation Time Step </h2>
<p>As you can see in all these modes, <a class="el" href="raceengine_8cpp.html#a47222ca180011ccaf70df056baacda2f">ReOneStep</a> in <a class="el" href="raceengine_8cpp.html">src/libs/raceengineclient/raceengine.cpp</a> is then called at some point, this actually executes the simulation time step. Here is a good point to set a break point to investigate the call stack when you are new to the TORCS code base.</p>
<p>The discretisation and simulation loop has another consequence which is to consider: Lets assume that we disable everything which changes car properties, so we have no damage, use no fuel, etc. Now you would expect that a non learning, perfect controlled, hard coded robot would drive lap by lap the same lap (and lap time), would you? But that is not the case. Lets assume that we hit on our Nth lap accidently exactly the starting line with the car center, and let us draw a point on every simulated time step on the track. Now when we finish the Nth lap it is very unlikely that we hit exactly the same point where we started because of time discretisation, so every consecutive lap will be similar but not identical.</p>
<p>Simulation time limits: Because the simulation time is represented as double, and the simulation time step is finite (<a class="el" href="raceman_8h.html#a4ee107730ee9d3c8fb701398ea04ef92">RCM_MAX_DT_SIMU</a>) applications are expected to run stable up to 1 Million Days simulation time (the simulation core itself does only depend on the time step, so it would run stable for ever). The longest known performed experiments are 100000 km races in command line mode.</p>
<dl class="section author"><dt>Author</dt><dd>Bernhard Wymann </dd></dl>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
